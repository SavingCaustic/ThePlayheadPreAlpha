TODO
====


FOSS-lansering


* beatnik. ladda patch (samples) och lämna över till player

* dokumentation

* kunna spara parametrar som patch.
> och antagligen också settings?

* kunna ladda parametrar som patch.

* Kunna skicka disableRack så att vi kan göra operationer som ladda synth m.m.


POST


* börja med timing..

* WavReader kan ha Intro + SideA + SideB. När läsning av sideB börjar ska sideA uppdateras, om inte då hela alltet ryms i
intro + A + B. 32+32+32 = 96 kB. => mono 2 sek. xSedan behöver läsning ske varje sek.
Denna är ju synkron. Bara en tråd.

* Nåt med audioManager hotplugging som behver skruvas.

* metonom - var ska den in?

* kodstäd
  * rensa i skapande av globala objekt.



FIXAT:

* Load project
1) skapa yta för projectManager - OK!
2) RPC-endpoint för att ladda project - OK!
3) Läs in fil - metod i file-driver? readAsset, readUserAsset, readUser - OK!
4) Iterera över rack och units och objekt.
5) Sätt alla parametrar också. (!)

* Flera egenskaper *rack* sätts från endpoint. Risk för race.

* kodstäd (subklasser i player engine)

* modul-kul: delay.

* modul-kul: ocatver.


* kanske en eventor? En arpeggiator vore ju nice..
  * kräver klockpuls. avvakta..
  * Börja med ngt riktigt enkelt, retrigger typ

* factory-process
1) endpoint för factory rpc?unit.synth&rack_id=0&key=lut_osc1&value=1,0.5,0.3
2) parsa från main till rätt factory
3) lägga objekt i kö
4) poll av kö från player engine
5) överta pekare från kö
6) ev förstöra tidigare objekt.


rpc?rack.synth.delete
rpc?unit.synth&rack_id=0&key=lut_osc1&value=1,0.5,0.3

* object-destructor

* nåt slags filter för subsynth iaf.

* parameters i effects. Hur routa från midi-kbd i kombi med pager?
  * får väl bygga på enklare kbds.. en extra page?!

* mjuka övergångar - delta för parametrar. Registreras vid compile-time.

* ugh.. Hur göra med allt detta med Rack, units. Untis som kanske används någon annanstans.
CC-mapping inte spec. relevant. kontrollerns knyts till thePlayhead. spec av scroller.
Och hur göra med MidiCC som kan användas av både synth och effekt. Viktigt att mapping finns på rack.
cc_mapping, tja har man params har man cc_mapping. Vet iofs inte om rack i sig har params, bara settings..

* skicka svar från parametrar med både 0-1 och värdet, ex "40L"
gången är ju FE=>WS=>PE=>rack=>module. Ev tänka DNS här, så module=>WS istället för hela vägen tillbaka..

* snap på parametrar. Stöd för filter-typ i DummySynth.
Då behöver vi väl jämföra nuv position med ny föreslagen, så vi inte kallar lambdan i onödan.
Och då behöver vi veta om värdet vi är på väg att skriva är persistant eller temp (automation).
Kan vänta med automation med förbreda för det. (på väg att skapa egen klass här..)

* ok fixa detta med parameters nu.
* parameters är i class. + lambda.
* paramVals är data av parameters.
* stringVals är grejer som sätts av.
* deltas kan användas av DSP. 

* snap. nästan. :)
Vid ladda, finns inga patch-värden än. Ladda defaults från params.
Dubbelkolla. Detune o semi ska bli 0.
sen är snap klar!! :D

* Audio in.. Kanske ska vi ha en AudioManager. Denna kan ha in-buffers (alltid 2st), så kopplar DSP upp sig till deessa.
  Och det är audioManager som slår av/på själva drivern..

* Midi-in hotplugging. At interval (Stu)

* bättre initiering av callback - varför krash? Är det midi eller audio?

* Kötta i midi-implementeringen. Separat lab.

* Rensa så midi inte använder char

* Flytta endpoints till egen fil

* sine-synth. mono och bara AR, men för att testa LUT, frekvens o midi.

* döp om klassnamn för syntar men kanske behåll filnamn så man ser i vsCode.

* Ta bort depenencien till Rack på Unit. Pekar direkt på buffern bara.

* nåt som behöver göras om med parametrar. värdet ska ju omskapas innan det kastas in i lambdan.
Lambdan sja bara göra halva jobbet - skicka till moduler.
Sen behöver värdet sparas och skickas tillbaka. Gör utanför (return)
på sikt *kanske* vi kan skicka hela lambdan till ngn 'smoother' som körs 24ppqn typ.
eller tja, det kanske är så att automatiseringen får sköta det. en smoother per automatisering..

* Rensa dummyModel från grejer som borde vara i interface

* nåt sätt att aktivera / avaktivera rack för uppspelning. (inte lita på is_null)
* flytta rack så de är på stacken istället (snabbare buffer)

* byta huvudobject till stackspace

* rackInFocus i playerEngine(?) så den vet vart midi-meddelanden ska skickas.
rackReceivingMidi = 0-n; (-1 no midi in)

* midi-mapping av controller<>parameeter.. 
hur skulle detta gå till? Börja först med att testa cc..
asset-file per synth. funkar tills vidare. Sen vill man kanske kunna styra effekter också via CC..

* skapa message buffer för dessa svar

* websocket-server som kan ta emot dessa svar och skicka vidare till klient
  * Få igång websocket mellan FE och BE.
  * Kunna skicka nån parameter. Vad? NoteOn typ.. format?
  {cmd:noteOn,key:69}, {cmd:noteOff:key:69}
  {cmd:setParam,unit:synth,name:cutoff,value:100}

* testa audioError när parameter sätts..
* fixa lateny i audioError..
